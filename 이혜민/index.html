<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
    <header id="header">
        <div class="header__left">
            <h1>portfolio</h1>
            <nav>
                <ul>
                    <li>about me</li>
                    <li>project</li>
                    <li>contact</li>
                </ul>
            </nav>
        </div>
        <div class="header__right">
            <ul>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>
    </header>

    <section id="section1">
        <div class="center">
            <h2>IncreDorable</h2>
            <p>끊임없이 혁신적인 웹 프론트엔드 솔루션을 창조하는<br>밝고 창의적인 프론트 개발자로 항상 노력하고 있습니다.</p>
        </div>
        <canvas id="canvas"></canvas>
    </section>
    <!-- //section -->

    <section id="section2">
        <div class="container">
            <div class="about">
                <span>about me 😇</span>
                끊임없이 혁신적인 웹 프론트엔드 솔루션을 창조하는 밝고 창의적인 프론트 개발자로서, 저는 <em>최신 기술 트렌드에</em> 발맞춰 항상 발전하고자 노력하고 있습니다.
                <strong>사용자 경험을</strong> 최우선으로 여기며,
                모든 프로젝트에 심미적이고 기능적인 접근을 취함으로써 <b>디지털 세계의 미래를 형성하는 데 기여하고자 합니다</b>.🥳😘🥰
            </div>
        </div>
        <div class="line1">Potencial <span>😎</span> Potencial <span>🥳😘🥰</span> Potencial</div>
        <div class="line2">Creativity <span>🥰</span> Creativity <span>😜</span> Creativity</div>
        <div class="line3">Sensbility <span>😎</span> Sensbility <span>😘</span> Sensbility</div>
    </section>
    <!-- //section -->

    <section id="section3">
        <div class="container">
            <div class="about">
                <span>work list 👏</span>
                저의 포트폴리오는 혁신적인 웹 <em>프론트엔드 디자인과</em> 개발에 초점을 맞추고 있습니다.
                사용자 친화적인 인터페이스와 독창적인 시각적 요소를 결합하여,
                각 프로젝트는 독특하면서도 <strong>직관적인 사용자 경험을</strong> 제공합니다.
                이 포트폴리오는 제가 참여한 다양한 프로젝트들을 통해 <b>기술적 능력과 창의적인 해결책을 보여줍니다</b>
            </div>

            <div class="site-wrap">
                <div class="site s1">
                    <h3>youtube site</h3>
                    <p>
                        JavaScript를 활용하여 '이미지 퀴즈' 웹사이트를 제작하였습니다.
                        이 웹사이트는 사용자가 4개의 이미지 중 문제에 해당하는 이미지를 선택하여 정답을 맞추는 퀴즈 형식을 통해 사용자의 일반 상식 수준을 재미있게 확인할 수 있습니다.
                        이 웹사이트의 특징은 직관적인 이미지 선택을 통한 퀴즈 제공으로, 사용자들이 문제를 보다 쉽고 빠르게 이해하고, 답변할 수 있도록 디자인되었습니다.
                    </p>
                    <div class="tag">
                        <div>
                            <span>3weeks</span>
                            <span>Javascript</span>
                            <span>Quiz</span>
                            <span>Team</span>
                        </div>
                        <div>
                            <span>view</span>
                            <span>code</span>
                        </div>
                    </div>
                </div>
                <div class="site s2"></div>
                <div class="site s3"></div>
                <div class="site s4"></div>
            </div>
        </div>
    </section>
    <!-- //section -->

    <section id="section4"></section><!-- //section -->
    <section id="section5"></section><!-- //section -->
    <section id="section6"></section><!-- //section -->


    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js"></script>
    <script>
        function random(low, high) {
            return Math.random() * (high - low) + low;
        }

        class Visual {
            constructor() {
                this.canvas = document.querySelector('#canvas');
                this.context = this.canvas.getContext('2d');
                this.canvasWidth = 0;
                this.canvasHeight = 0;
                this.particleLength = 150;
                this.particles = [];
                this.particleMaxRadius = 8;

                this.handleMouseMoveBind = this.handleMouseMove.bind(this);
                this.handleClickBind = this.handleClick.bind(this);
                this.handleResizeBind = this.handleResize.bind(this);

                this.initialize();
                this.render();
            }

            initialize() {
                this.resizeCanvas();
                for (let i = 0; i < this.particleLength; i++) {
                    this.particles.push(this.createParticle(i));
                }
                this.bind();
            }

            bind() {
                document.body.addEventListener('mousemove', this.handleMouseMoveBind, false);
                document.body.addEventListener('click', this.handleClickBind, false);
                window.addEventListener('resize', this.handleResizeBind, false);
            }

            unbind() {
                document.body.removeEventListener('mousemove', this.handleMouseMoveBind, false);
                document.body.removeEventListener('click', this.handleClickBind, false);
                window.removeEventListener('resize', this.handleResizeBind, false);
            }

            handleMouseMove(e) {
                this.enlargeParticle(e.clientX, e.clientY);
            }

            handleClick(e) {
                this.burstParticle(e.clientX, e.clientY);
            }

            handleResize() {
                this.resizeCanvas();
            }

            resizeCanvas() {
                this.canvasWidth = document.body.offsetWidth;
                this.canvasHeight = document.body.offsetHeight;
                this.canvas.width = this.canvasWidth * window.devicePixelRatio;
                this.canvas.height = this.canvasHeight * window.devicePixelRatio;
                this.context = this.canvas.getContext('2d');
                this.context.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            createParticle(id, isRecreate) {
                const radius = random(1, this.particleMaxRadius);
                const x = isRecreate ? -radius - random(0, this.canvasWidth) : random(0, this.canvasWidth);
                let y = random(this.canvasHeight / 2 - 150, this.canvasHeight / 2 + 150);
                y += random(-100, 100);
                const alpha = random(0.05, 1);

                return {
                    id: id,
                    x: x,
                    y: y,
                    startY: y,
                    radius: radius,
                    defaultRadius: radius,
                    startAngle: 0,
                    endAngle: Math.PI * 2,
                    alpha: alpha,
                    color: { r: random(0, 100), g: random(0, 100), b: 255 },
                    speed: alpha + 1,
                    amplitude: random(50, 200),
                    isBurst: false
                };
            }

            drawParticles() {
                this.particles.forEach(particle => {
                    // 位置情報更新
                    this.moveParticle(particle);

                    // particle描画
                    this.context.beginPath();
                    this.context.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha})`;
                    this.context.arc(particle.x, particle.y, particle.radius, particle.startAngle, particle.endAngle);
                    this.context.fill();
                });
            }

            moveParticle(particle) {
                particle.x += particle.speed;
                particle.y = particle.startY + particle.amplitude * Math.sin(((particle.x / 5) * Math.PI) / 180);
            }

            enlargeParticle(clientX, clientY) {
                this.particles.forEach(particle => {
                    if (particle.isBurst) return;

                    const distance = Math.hypot(particle.x - clientX, particle.y - clientY);

                    if (distance <= 100) {
                        const scaling = (100 - distance) / 1.5;
                        TweenMax.to(particle, 0.5, {
                            radius: particle.defaultRadius + scaling,
                            ease: Power2.easeOut
                        });
                    } else {
                        TweenMax.to(particle, 0.5, {
                            radius: particle.defaultRadius,
                            ease: Power2.easeOut
                        });
                    }
                });
            }

            burstParticle(clientX, clientY) {
                this.particles.forEach(particle => {
                    const distance = Math.hypot(particle.x - clientX, particle.y - clientY);

                    if (distance <= 100) {
                        particle.isBurst = true;
                        TweenMax.to(particle, 0.5, {
                            radius: particle.defaultRadius + 200,
                            alpha: 0,
                            ease: Power2.easeOut,
                            onComplete: () => {
                                this.particles[particle.id] = this.createParticle(particle.id, true);
                            }
                        });
                    }
                });
            }

            render() {
                // canvas初期化
                this.context.clearRect(0, 0, this.canvasWidth + this.particleMaxRadius * 2, this.canvasHeight);

                // particleを描画
                this.drawParticles();

                // 画面から消えたら新しいparticleに差し替え
                this.particles.forEach(particle => {
                    if (particle.x - particle.radius >= this.canvasWidth) {
                        this.particles[particle.id] = this.createParticle(particle.id, true);
                    }
                });

                requestAnimationFrame(this.render.bind(this));
            }
        }

        new Visual();
    </script>
</body>

</html>